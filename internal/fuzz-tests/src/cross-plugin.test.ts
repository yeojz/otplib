import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import { generate as generateHOTP, verify as verifyHOTP } from "@otplib/hotp";
import { generate as generateTOTP, verify as verifyTOTP } from "@otplib/totp";
import { NodeCryptoPlugin } from "@otplib/plugin-crypto-node";
import { NobleCryptoPlugin } from "@otplib/plugin-crypto-noble";
import { ScureBase32Plugin } from "@otplib/plugin-base32-scure";

import type { CryptoPlugin } from "@otplib/core";

type NamedCryptoPlugin = {
  name: string;
  plugin: CryptoPlugin;
};

// Add new crypto plugins here
const cryptoPlugins: NamedCryptoPlugin[] = [
  { name: "Node.js", plugin: new NodeCryptoPlugin() },
  { name: "Noble", plugin: new NobleCryptoPlugin() },
];

const base32 = new ScureBase32Plugin();

type PluginPairTestCase = {
  pairName: string;
  pluginA: NamedCryptoPlugin;
  pluginB: NamedCryptoPlugin;
};

function getPluginPairs(): PluginPairTestCase[] {
  const pairs: PluginPairTestCase[] = [];
  for (let i = 0; i < cryptoPlugins.length; i++) {
    for (let j = i + 1; j < cryptoPlugins.length; j++) {
      pairs.push({
        pairName: `${cryptoPlugins[i].name} vs ${cryptoPlugins[j].name}`,
        pluginA: cryptoPlugins[i],
        pluginB: cryptoPlugins[j],
      });
    }
  }
  return pairs;
}

const pluginPairs = getPluginPairs();

const validAlgorithm = fc.constantFrom("sha1", "sha256", "sha512") as fc.Arbitrary<
  "sha1" | "sha256" | "sha512"
>;

describe("Cross-plugin consistency tests", () => {
  describe("HMAC output consistency", () => {
    describe.each(pluginPairs)("$pairName", ({ pluginA, pluginB }) => {
      it.each(["sha1", "sha256", "sha512"] as const)(
        "should produce identical HMAC outputs for %s",
        async (algorithm) => {
          await fc.assert(
            fc.asyncProperty(
              fc.uint8Array({ minLength: 16, maxLength: 64 }),
              fc.uint8Array({ minLength: 1, maxLength: 256 }),
              async (key, data) => {
                const resultA = await pluginA.plugin.hmac(algorithm, key, data);
                const resultB = await pluginB.plugin.hmac(algorithm, key, data);

                expect(resultA).toEqual(resultB);
              },
            ),
          );
        },
      );

      it("should produce identical HMAC outputs across all algorithms", async () => {
        await fc.assert(
          fc.asyncProperty(
            fc.uint8Array({ minLength: 16, maxLength: 64 }),
            fc.uint8Array({ minLength: 1, maxLength: 256 }),
            validAlgorithm,
            async (key, data, algorithm) => {
              const resultA = await pluginA.plugin.hmac(algorithm, key, data);
              const resultB = await pluginB.plugin.hmac(algorithm, key, data);

              expect(resultA).toEqual(resultB);
            },
          ),
        );
      });
    });
  });

  describe("HOTP token consistency", () => {
    describe.each(pluginPairs)("$pairName", ({ pluginA, pluginB }) => {
      it("should generate identical HOTP tokens", async () => {
        await fc.assert(
          fc.asyncProperty(
            fc.uint8Array({ minLength: 16, maxLength: 64 }),
            fc.integer({ min: 0, max: 1000000 }),
            validAlgorithm,
            fc.constantFrom(6, 7, 8) as fc.Arbitrary<6 | 7 | 8>,
            async (secret, counter, algorithm, digits) => {
              const tokenA = await generateHOTP({
                secret,
                counter,
                algorithm,
                digits,
                crypto: pluginA.plugin,
                base32,
              });

              const tokenB = await generateHOTP({
                secret,
                counter,
                algorithm,
                digits,
                crypto: pluginB.plugin,
                base32,
              });

              expect(tokenA).toBe(tokenB);
            },
          ),
        );
      });

      it("should verify HOTP tokens generated by the other plugin", async () => {
        await fc.assert(
          fc.asyncProperty(
            fc.uint8Array({ minLength: 16, maxLength: 64 }),
            fc.integer({ min: 0, max: 1000000 }),
            async (secret, counter) => {
              const tokenA = await generateHOTP({
                secret,
                counter,
                crypto: pluginA.plugin,
                base32,
              });

              const verifyWithB = await verifyHOTP({
                secret,
                counter,
                token: tokenA,
                crypto: pluginB.plugin,
                base32,
              });

              expect(verifyWithB.valid).toBe(true);

              const tokenB = await generateHOTP({
                secret,
                counter,
                crypto: pluginB.plugin,
                base32,
              });

              const verifyWithA = await verifyHOTP({
                secret,
                counter,
                token: tokenB,
                crypto: pluginA.plugin,
                base32,
              });

              expect(verifyWithA.valid).toBe(true);
            },
          ),
        );
      });
    });
  });

  describe("TOTP token consistency", () => {
    describe.each(pluginPairs)("$pairName", ({ pluginA, pluginB }) => {
      it("should generate identical TOTP tokens", async () => {
        await fc.assert(
          fc.asyncProperty(
            fc.uint8Array({ minLength: 16, maxLength: 64 }),
            fc.integer({ min: 0, max: 2000000000 }),
            validAlgorithm,
            fc.constantFrom(6, 7, 8) as fc.Arbitrary<6 | 7 | 8>,
            fc.integer({ min: 30, max: 60 }),
            async (secret, epoch, algorithm, digits, period) => {
              const tokenA = await generateTOTP({
                secret,
                epoch,
                algorithm,
                digits,
                period,
                crypto: pluginA.plugin,
                base32,
              });

              const tokenB = await generateTOTP({
                secret,
                epoch,
                algorithm,
                digits,
                period,
                crypto: pluginB.plugin,
                base32,
              });

              expect(tokenA).toBe(tokenB);
            },
          ),
        );
      });

      it("should verify TOTP tokens generated by the other plugin", async () => {
        await fc.assert(
          fc.asyncProperty(
            fc.uint8Array({ minLength: 16, maxLength: 64 }),
            fc.integer({ min: 0, max: 2000000000 }),
            async (secret, epoch) => {
              const tokenA = await generateTOTP({
                secret,
                epoch,
                crypto: pluginA.plugin,
                base32,
              });

              const verifyWithB = await verifyTOTP({
                secret,
                epoch,
                token: tokenA,
                crypto: pluginB.plugin,
                base32,
              });

              expect(verifyWithB.valid).toBe(true);

              const tokenB = await generateTOTP({
                secret,
                epoch,
                crypto: pluginB.plugin,
                base32,
              });

              const verifyWithA = await verifyTOTP({
                secret,
                epoch,
                token: tokenB,
                crypto: pluginA.plugin,
                base32,
              });

              expect(verifyWithA.valid).toBe(true);
            },
          ),
        );
      });
    });
  });

  describe("Edge cases", () => {
    describe.each(pluginPairs)("$pairName", ({ pluginA, pluginB }) => {
      it("should handle empty data for HMAC consistently", async () => {
        await fc.assert(
          fc.asyncProperty(
            fc.uint8Array({ minLength: 16, maxLength: 64 }),
            validAlgorithm,
            async (key, algorithm) => {
              const emptyData = new Uint8Array(0);

              const resultA = await pluginA.plugin.hmac(algorithm, key, emptyData);
              const resultB = await pluginB.plugin.hmac(algorithm, key, emptyData);

              expect(resultA).toEqual(resultB);
            },
          ),
        );
      });

      it("should handle counter at boundary values", async () => {
        await fc.assert(
          fc.asyncProperty(
            fc.uint8Array({ minLength: 16, maxLength: 64 }),
            fc.constantFrom(0, 1, Number.MAX_SAFE_INTEGER - 1),
            async (secret, counter) => {
              const tokenA = await generateHOTP({
                secret,
                counter,
                crypto: pluginA.plugin,
                base32,
              });

              const tokenB = await generateHOTP({
                secret,
                counter,
                crypto: pluginB.plugin,
                base32,
              });

              expect(tokenA).toBe(tokenB);
            },
          ),
        );
      });

      it("should handle epoch at boundary values (including 0)", async () => {
        await fc.assert(
          fc.asyncProperty(
            fc.uint8Array({ minLength: 16, maxLength: 64 }),
            fc.constantFrom(0, 1, Number.MAX_SAFE_INTEGER - 1),
            async (secret, epoch) => {
              const tokenA = await generateTOTP({
                secret,
                epoch,
                crypto: pluginA.plugin,
                base32,
              });

              const tokenB = await generateTOTP({
                secret,
                epoch,
                crypto: pluginB.plugin,
                base32,
              });

              expect(tokenA).toBe(tokenB);
            },
          ),
        );
      });

      it("should handle minimum secret length (16 bytes)", async () => {
        await fc.assert(
          fc.asyncProperty(fc.integer({ min: 0, max: 1000000 }), async (counter) => {
            const minSecret = new Uint8Array(16).fill(0x42);

            const tokenA = await generateHOTP({
              secret: minSecret,
              counter,
              crypto: pluginA.plugin,
              base32,
            });

            const tokenB = await generateHOTP({
              secret: minSecret,
              counter,
              crypto: pluginB.plugin,
              base32,
            });

            expect(tokenA).toBe(tokenB);
          }),
        );
      });

      it("should handle large secret length (64 bytes for SHA-512)", async () => {
        await fc.assert(
          fc.asyncProperty(fc.integer({ min: 0, max: 1000000 }), async (counter) => {
            const largeSecret = new Uint8Array(64).fill(0xab);

            const tokenA = await generateHOTP({
              secret: largeSecret,
              counter,
              algorithm: "sha512",
              crypto: pluginA.plugin,
              base32,
            });

            const tokenB = await generateHOTP({
              secret: largeSecret,
              counter,
              algorithm: "sha512",
              crypto: pluginB.plugin,
              base32,
            });

            expect(tokenA).toBe(tokenB);
          }),
        );
      });
    });
  });

  describe("All plugins produce identical results", () => {
    it("should have all plugins generate the same HMAC for the same input", async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uint8Array({ minLength: 16, maxLength: 64 }),
          fc.uint8Array({ minLength: 1, maxLength: 256 }),
          validAlgorithm,
          async (key, data, algorithm) => {
            const results = await Promise.all(
              cryptoPlugins.map((p) => p.plugin.hmac(algorithm, key, data)),
            );

            const first = results[0];
            for (let i = 1; i < results.length; i++) {
              expect(results[i]).toEqual(first);
            }
          },
        ),
      );
    });

    it("should have all plugins generate the same HOTP token for the same input", async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uint8Array({ minLength: 16, maxLength: 64 }),
          fc.integer({ min: 0, max: 1000000 }),
          validAlgorithm,
          fc.constantFrom(6, 7, 8) as fc.Arbitrary<6 | 7 | 8>,
          async (secret, counter, algorithm, digits) => {
            const tokens = await Promise.all(
              cryptoPlugins.map((p) =>
                generateHOTP({
                  secret,
                  counter,
                  algorithm,
                  digits,
                  crypto: p.plugin,
                  base32,
                }),
              ),
            );

            const first = tokens[0];
            for (let i = 1; i < tokens.length; i++) {
              expect(tokens[i]).toBe(first);
            }
          },
        ),
      );
    });

    it("should have all plugins generate the same TOTP token for the same input", async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uint8Array({ minLength: 16, maxLength: 64 }),
          fc.integer({ min: 0, max: 2000000000 }),
          validAlgorithm,
          fc.constantFrom(6, 7, 8) as fc.Arbitrary<6 | 7 | 8>,
          fc.integer({ min: 30, max: 60 }),
          async (secret, epoch, algorithm, digits, period) => {
            const tokens = await Promise.all(
              cryptoPlugins.map((p) =>
                generateTOTP({
                  secret,
                  epoch,
                  algorithm,
                  digits,
                  period,
                  crypto: p.plugin,
                  base32,
                }),
              ),
            );

            const first = tokens[0];
            for (let i = 1; i < tokens.length; i++) {
              expect(tokens[i]).toBe(first);
            }
          },
        ),
      );
    });
  });
});
